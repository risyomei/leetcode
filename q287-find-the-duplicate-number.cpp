/*
ANSWER
-------------------------------------------------------------------------------------
这道题实在TMD的变态了。我能正常想到的方法是按值进行二分法。

BinarySearch的解释：
[1,3,4,2,2] 这个长度是5，所以一共有4个不同的数(一个重复)
按值BinarySearch，先看比<=2的有多少个 (4的一半是2)

扫描一轮 (分界2, 目标2), 发现1,2,2 三个数满足，这大于目标个数2所以按这个range
扫描二轮 (分界1, 目标1), 发现1 一个数满足，和目标相同，所以选择另外一个range
扫描三轮 (分界2, 目标1), 发现2,2 两个数满足，这大于目标个数、而且[2,2]这有一个数，所以算法结束

复杂度 binarySearch logN * 每次要扫描N个 =~ O(NlogN) 

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
但是这个题真正变态的是解法2:也就是这个题我提交的解法, 用作快慢指针，找环的方法。。。

关键在于把这个问题转换成找环:
比如：
[1 3 2 4 5 3] 这个Case，可以做如下转换：

跟所有的 value 标上index.
Index:  0 1 2 3 4 5
Value: [1 3 2 4 5 3]

令初始index=0，一直往下推，直到产生环，那么环的开始节点就是重复的节点
f(0): 1 
f(1): 3
f(3): 4
f(4): 5
f(5): 3 --> 产生环

1-3-4-5 
  |   |
  └---┘
    
反思：
1. 为什么环的开始节点就是重复的节点？
因为在value数组中存在两个相同的数，即存在 m!=n  满足 f(m) = f(n)
也就是这个数有两个入度(两个数指向它)，这就会产生环。

2. 怎么保证所有的点都会遍历到？
并不能保证，比如这个例子中2就和其他的数构成的图不联通。但这不会影响结论
2--┐
|  |
└--┘

3. 为何从index=0开始？
因为value是没法取值0的、所以f(0)的入度为0(也就是没有数可以指向0)，
所以0按照道理来说，是没法形成环的。如果形成了环，一定是有重复的数。

具体找环的方法请见q142.
-------------------------------------------------------------------------------------
*/

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        
        if( nums.size()<=1 ){
            return 0;
        }
        
        int slow = nums[0];
        int fast = nums[nums[0]];
        
        while( slow != fast  ){
            slow = nums[slow];
            fast = nums[nums[fast]];            
        }
        
        slow = 0;
        
        while(slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }
};
